/* scanner for a Mini Pascal */

%{
#include <stdio.h>
#include <stdlib.h>
#include "structs.h"
#include "parser.tab.h"   /* will be generated by Bison */

int linenr = 1;
int colnr  = 1;

static char *inputbuffer;

static void eat() {
  char *s;
  for (s=yytext; *s; s++) {
    if (*s == '\n') {
      linenr++;
      colnr = 0;
    } 
    colnr++;
  }
}

%}

DIGIT    [0-9]
ID       [a-zA-Z][a-zA-Z0-9_]*

%%

[Pp][Rr][Oo][Gg][Rr][Aa][Mm]         { eat(); return PROGRAM;    }
[Vv][Aa][Rr]                         { eat(); return VAR;        }
[Cc][Oo][Nn][Ss][Tt]                 { eat(); return CONST;      }
[Aa][Rr][Rr][Aa][Yy]                 { eat(); return ARRAY;      }
[Oo][Ff]                             { eat(); return OF;         }
[Ii][Nn][Tt][Ee][Gg][Ee][Rr]         { eat(); return INTEGER;    }
[Rr][Ee][Aa][Ll]                     { eat(); return REAL;       }
[Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]     { eat(); return FUNCTION;   }
[Pp][Rr][Oo][Cc][Ee][Dd][Uu][Rr][Ee] { eat(); return PROCEDURE;  }
[Bb][Ee][Gg][Ii][Nn]                 { eat(); return BEGINTOK;   }
[Ee][Nn][Dd]                         { eat(); return ENDTOK;     }
[Ii][Ff]                             { eat(); return IF;         }
[Tt][Hh][Ee][Nn]                     { eat(); return THEN;       }
[Ee][Ll][Ss][Ee]                     { eat(); return ELSE;       }
[Ww][Hh][Ii][Ll][Ee]                 { eat(); return WHILE;      }
[Dd][Oo]                             { eat(); return DO;         }
[Aa][Nn][Dd]                         { eat(); return AND;        }
[Oo][Rr]                             { eat(); return OR;         }
[Nn][Oo][Tt]                         { eat(); return NOT;        }
[Rr][Ee][Aa][Dd][Ll][Nn]             { eat(); return READLN;     }
[Ww][Rr][Ii][Tt][Ee][Ll][Nn]         { eat(); return WRITELN;    }
[Ss][Kk][Ii][Pp]                     { eat(); return SKIP;       }

"."                                  { eat(); return (*yytext);  }
"("                                  { eat(); return (*yytext);  }
")"                                  { eat(); return (*yytext);  }
"["                                  { eat(); return (*yytext);  }
"]"                                  { eat(); return (*yytext);  }
","                                  { eat(); return (*yytext);  }
";"                                  { eat(); return (*yytext);  }
":"                                  { eat(); return (*yytext);  }
".."                                 { eat(); return RANGE;      }
":="                                 { eat(); return ASSIGN;     }
"<"                                  { eat(); return RELOPLT;    }
"<="                                 { eat(); return RELOPLEQ;   }
"="                                  { eat(); return RELOPEQ;    }
">="                                 { eat(); return RELOPGEQ;   }
">"                                  { eat(); return RELOPGT;    }
"<>"                                 { eat(); return RELOPNEQ;   }
"+"                                  { eat(); return (*yytext);  }
"-"                                  { eat(); return (*yytext);  }
"*"                                  { eat(); return (*yytext);  }
"/"                                  { eat(); return (*yytext);  }
[Dd][Ii][Vv]                         { eat(); return DIV;        }
[Mm][Oo][Dd]                         { eat(); return MOD;        }

{DIGIT}+                             { eat(); yylval.ival = atoi(yytext); return INTNUMBER; }
{DIGIT}+"."{DIGIT}+                  { eat(); yylval.dval = atof(yytext); return REALNUMBER; }
{ID}                                 { eat(); yylval.sval = strdup(yytext); return IDENTIFIER; }

"{"[^}]*"}"                          { eat(); /* eat comment */  }

[ \t]+                               { eat(); /* whitespace */   }
\n                                   { linenr++; colnr = 1;      }

.           {
              fprintf(stderr, "Unrecognized character '%c' in line %d.\n", *yytext, linenr);
              printf("ERRORS: 1\nWARNINGS: 0\nREJECTED\n");
              exit(EXIT_SUCCESS);
            }


%%
void initLexer(FILE *f) {
  int length;
  fseek (f, 0, SEEK_END);
  length = ftell (f);
  fseek (f, 0, SEEK_SET);
  inputbuffer = malloc (length+1);
  inputbuffer[length]='\0';
  length = fread (inputbuffer, 1, length, f);
  fseek (f, 0, SEEK_SET);
  yyin = f;
}

void showErrorLine() {
  char *p = inputbuffer;
  int line = linenr;
  while ((*p != '\0') && (line > 1)) {
    line -= (*p == '\n');
    p++;
  }
  fprintf(stderr, "line %3d: ", linenr);
  while ((*p != '\0') && (*p != '\n')) {
    putc(*p != '\t' ? *p : ' ', stderr);
    p++;
  }
  putc('\n', stderr);
  fprintf(stderr, "---------");
  for (int i=colnr-strlen(yytext); i>0; i--) {
    putc('-', stderr);
  }
  fprintf(stderr, "^\n");
}
 
void finalizeLexer() {
  free(inputbuffer);
  yylex_destroy();
}
